
Шаг 4. Создаем формальные спецификации АТД

Кластер PlayingField  
1. Element - АТД для возможных типов элементов:
1.1 BaseElement - класс, реализующий АТД Element, обычный элемент состоящий из букв (A, B, C, D, E);
1.2 BonusElement - класс, реализующий АТД Element, бонус-элемент, со своим сценарием использования.
  
2. FieldFactory - фабрика для генерации рандомных элементов игрового поля/Возможно стоит переименовать в ElementFactory

3. BaseField - АТД для возможных типов полей. Как база в случае необходимости для создания другого вида поля.
3.1 Field - класс, реализующий АТД Field, конкретная реализацию игрового поля в виде сетки размером 8х8.

4. Возможное АТД Position. Как вспомогательный класс для обработки координат 

  
Кластер имзменю в названии на StrategyRules (через паттерн Strategy). 
Можно использовать несколько стратегий со своими правилами.
Стратегии оказываются несколько размазанными, здесь оставляю относящееся к проверкам логики игры
  
5.1 MatchPolicyStrategy - стратегия обнаружения совпадений
5.2 MoveValidationStrategy - стратегия валидации хода
5.3 PossibleMovesStrategy - проверка наличия возможных ходов
5.4 StrategyControl - объединение и управление возможными стратегиями (для возможного изменения-расширения правил игры)
  Возможно применить
5.5 MatchGroup - конкретное совпадение 
5.6 MatchResult - список всех совпавших элементов


  
Кластер, относящийся к подсчётам и статистике ScoresAndHistory
6. ScoringPolicyStrategy - стратегия для подсчёта очков при совпадении
7. HistoryMove - история совершённых ходов
7.1 MoveRecord - класс для хранения данных хода
  
  
Возможно стоит выделить отдельный кластер связанный с условным вводом-выводом информации
Предварительное название может быть Application
8. InputControl - проверяет и распознаё вводимые данные игроком
9. OutputControl - выводит данные игроку

И пока отдельными будут классы:
10. EndGamePolicyStrategy - как стратегию окончания игры (возможно следует перенести в кластер StrategyRules)
  
11. GameRules - в качестве класса управления всеми ненобходимыми стратегиями

12. GameLoop - в котором будет происходить весь цикл игры


  
  
Шаг 5. Уточняем формальные спецификации АТД
Отдельныо придётся поразмыслить над каждым классом, пока определяю основные запросы/команды/инварианты
  
1. Абстрактный класс Element:
Возможные поля: symbol (само буквенное значение), value (стоимость элемента, засчитывается в очки пользователя при комбинации).
Возможные запросы: - получить символ,
                   - получить стоимость.
2. Класс FieldFactory:
Возможные запросы: - получить случайный элемент.
3.1 Класс Field:
Инвариант: rows > 0 и cols > 0
Возможные поля: массив elements.
Возможные запросы: - получить символ по координатам, 
                   - вывести текущее состояние игрового поля;
Возможные команды: - заполнить пустые ячейки игрового поля.
4. Класс Position
Инвариант: rows >= 0 и cols >= 0
Возможные запросы: - доступ к координатам



5.1 MatchPolicyStrategy 
Возможный метод: - findMatches.
Возможный результат: - список MatchGroup
Возможные реализации: - Line3PlusMatchPolicy — горизонтали/вертикали ≥ 3.
                      - SpecialShapesPolicy — добавляет крест.
5.2 MoveValidationStrategy 
Возможный метод: - boolean isValid.
5.3 PossibleMovesStrategy 
Возможный метод: - boolean isMoveAvailable.
5.5 MatchGroup
Возможные поля: orientation(гор, верт), positions (список последовательности в координатах)
Возможные запросы: - ориентация
                   - позиция координат
                   - длина
5.6 MatchResult
Возможные поля: весь набор найденных совпадений



6. ScoringPolicyStrategy - стратегия для подсчёта очков при совпадении
Возможные реализации: подсчёт может осуществляться разными вариантами, за базу можно взять SimpleProgressiveScoring
7. HistoryMove - история совершённых ходов
Возможные запросы: - суммарные очки
                   - сколько ходов сделано
Возможные команды: - очистить статистику на рестарте партии.
                   - добавить запись о завершённом ходе


  
10. EndGamePolicyStrategy  
Возможные реализации: - NoMovesLeftEndGame, 
                        MovesLimitEndGame(n)


Имеются вопросы во многих местах, но это уже более чёткий набросок
